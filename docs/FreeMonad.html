<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0">
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
<title>
ç‚¹èœæ•°æ®ç±»å‹ (Data types Ã  la carte)</title>
<link href="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.13.13/katex.min.css" rel="stylesheet"><style>
body {
    max-width: 650px;
    margin: auto;
    width: 90%;
    margin-top: 10%;
    margin-bottom: 10%;
    color: #0B0E26;
    background: #FAFAFC;
    line-height: 2em;
    font-variant-ligatures: common-ligatures;
    -webkit-font-feature-settings: "liga" on, "calt" on;
    font-feature-settings: "liga" on, "calt" on;
}

body {
    font-size: 20px;
    font-family: -apple-system, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Microsoft YaHei, Source Han Sans SC, Noto Sans CJK SC, WenQuanYi Micro Hei, sans-serif;
}

h1 {
    font-size: 2.5em;
    color: #EF96AB;
    line-height: 1.5em;
}

h2 {
    margin-top: 2em;
    line-height: 1.5em;
}

h1,
h2,
h3 {
    /* text-align: center; */
}

blockquote {
    color: gray;
    margin: 0;
    padding: 1 1 1 20;
    border-left: 5px solid #EF96AB;
}

code,
pre {
    font-size: 0.9em;
    line-height: 1.8em;
    font-family: "JetBrains Mono", "ç­‰è·æ›´çº±é»‘ä½“ SC", "Fira Code", Menlo, Monaco, source-code-pro, Courier New, Consolas, monospace;
    background: #FCF6FC;
    border-radius: 3px;
    padding-inline: 0.3rem;
}

pre {
    overflow-x: auto;
    padding: 1rem;
}

pre>code {
    padding-inline: 0;
}

::-webkit-scrollbar,
.element::-webkit-scrollbar,
.element {
    /* opacity: 0.5; */
}

a {
    color: #02AEF1;
    text-decoration: none;
}

@media (prefers-color-scheme: dark) {
    body {
        color: #D8D8D6;
        background: #0E0E10;
    }
}

@media (prefers-color-scheme: dark) {

    pre,
    code {
        color: #D8D8D6;
        background: #0E0F1F;
    }
}

.hljs-keyword {
    color: #F288AF;
}

.hljs-comment {
    color: #929CA6;
}

.hljs-string {
    color: #0594A6;
}

.hljs-title {
    color: #4581D9;
}

.hljs-type,
.hljs-built_in {
    color: #fca311;
}</style>
</head>
<body>
<p>
<a href="https://iota.huohuo.moe">ğŸ HomepageğŸ </a> | <a href="https://github.com/niltok">ğŸ”¥GitHubğŸ”¥</a></p>
<h1 id="ç‚¹èœæ•°æ®ç±»å‹-data-types-Ã -la-carte">ç‚¹èœæ•°æ®ç±»å‹ (Data types Ã  la carte)</h1>
<blockquote>
<p>æœ¬æ–‡æ˜¯ <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/data-types-a-la-carte/14416CB20C4637164EA9F77097909409#">è¿™ç¯‡è®ºæ–‡</a> çš„ç²—ç•¥ç§‘æ™®ï¼Œä¸€äº›æ¯”è¾ƒç»†èŠ‚çš„åœ°æ–¹è¿˜æ˜¯å»ºè®®å»è¯»åŸæ–‡äº†è§£ã€‚</p>
</blockquote>
<h2 id="expression-problem">Expression problem</h2>
<p>åœ¨ Haskell ä¸­å®ç°ä¸€ä¸ªç®€å•çš„è¿ç®—è§£é‡Šå™¨æ˜¯ä»¶å¾ˆå®¹æ˜“çš„äº‹æƒ…ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Expr</span> = <span class="hljs-type">Val</span> <span class="hljs-type">Int</span> | <span class="hljs-type">Add</span> <span class="hljs-type">Expr</span> <span class="hljs-type">Expr</span></span>

<span class="hljs-title">eval</span> :: <span class="hljs-type">Expr</span> -&gt; <span class="hljs-type">Int</span>
<span class="hljs-title">eval</span> (<span class="hljs-type">Val</span> x) = x
<span class="hljs-title">eval</span> (<span class="hljs-type">Add</span> a b) = (eval a) + (eval b)
</code></pre>
<p>å®šä¹‰ <code>Expr</code> ç±»å‹ä¹‹åæˆ‘ä»¬è¿˜å¯ä»¥ä¸ºå®ƒæ·»åŠ ä¸€äº›åˆ«çš„åŠŸèƒ½ï¼Œæ¯”å¦‚æ‰“å°ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-title">render</span> :: <span class="hljs-type">Expr</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">render</span> (<span class="hljs-type">Val</span> x) = show x
<span class="hljs-title">render</span> (<span class="hljs-type">Add</span> a b) = <span class="hljs-string">&quot;(&quot;</span> ++ (render a) ++ <span class="hljs-string">&quot; + &quot;</span> ++ (render b) ++ <span class="hljs-string">&quot;)&quot;</span>
</code></pre>
<p>å¯ä»¥çœ‹åˆ°åƒè¿™æ ·å®šä¹‰çš„è¡¨è¾¾å¼ï¼Œæ·»åŠ ä¸€ä¸ªåŠŸèƒ½å¹¶ä¸éœ€è¦æ”¹åŠ¨åŸæ¥çš„ä»£ç ï¼Œéå¸¸å®¹æ˜“ï¼Œä½†å¦‚æœæƒ³æ‰©å±•è¡¨è¾¾å¼èŠ‚ç‚¹ç±»å‹ï¼Œå°±éœ€è¦ä¿®æ”¹æ‰€æœ‰çš„åŠŸèƒ½ä»£ç å¢åŠ æ¨¡å¼åŒ¹é…åˆ†æ”¯ï¼Œè¿™å°±éå¸¸éº»çƒ¦äº†ã€‚å¦‚æœç”¨ Java é‚£ç§é¢å‘å¯¹è±¡ç¼–ç¨‹çš„å¤„ç†æ–¹æ³•åˆä¼šå¯¼è‡´æ·»åŠ å­ç±»å¾ˆå®¹æ˜“ä½†æ·»åŠ æ–¹æ³•éœ€è¦ä¿®æ”¹æ‰€æœ‰å­ç±»ã€‚è€Œ Expression problem çš„ç›®æ ‡æ˜¯è®©æ‰©å±•åŠŸèƒ½å’Œæ‰©å±•èŠ‚ç‚¹ç±»å‹å°½é‡è§£è€¦ï¼Œä½¿æ·»åŠ æ–°åŠŸèƒ½å’Œæ–°ç±»å‹éƒ½ä¸éœ€è¦ä¿®æ”¹åŸå§‹ä»£ç ã€‚</p>
<h2 id="ç€æ‰‹å°è¯•è§£å†³">ç€æ‰‹å°è¯•è§£å†³</h2>
<p>æ—¢ç„¶å¸Œæœ›è‡ªç”±æ‰©å±•èŠ‚ç‚¹ç±»å‹å®šä¹‰é‚£åˆ†ç¦»ç±»å‹å®šä¹‰å’ŒèŠ‚ç‚¹å®šä¹‰åº”è¯¥æ˜¯çœ‹ä¸Šå»ä¸é”™çš„æ–¹å‘ã€‚æ¯”å¦‚ï¼Œè¿™é‡ŒæŠŠè¡¨è¾¾å¼çš„èŠ‚ç‚¹ç±»å‹å½“æˆ <code>Expr</code> ç±»å‹çš„å‚æ•° <code>f</code>ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Expr</span> f = <span class="hljs-type">In</span> (<span class="hljs-title">f</span> (<span class="hljs-type">Expr</span> <span class="hljs-title">f</span>))</span>
</code></pre>
<p>æ³¨æ„æ„é€ å™¨ <code>In</code> å‚æ•°çš„ç±»å‹ï¼Œå®ƒæŠŠ <code>Expr f</code> ä½œä¸ºäº† <code>f</code> çš„å‚æ•°ï¼Œè¿™æ · <code>f</code> å°±èƒ½æ‹¿åˆ°å®ƒæ‰€åœ¨çš„ä¸»è¡¨è¾¾å¼çš„ç±»å‹ï¼Œè¿›è€Œå¯ä»¥é€’å½’ä¼ é€’ç»™å­è¡¨è¾¾å¼ã€‚è¿™ä¸ªæ“ä½œå°±ç±»ä¼¼äº Y ç»„åˆå­æŠŠ <code>Y f</code> ä½œä¸º self å‚æ•°ä¼ é€’ç»™é€’å½’å‡½æ•°ã€‚è¿™æ ·ä¸€æ¥å°±å¯åˆ†åˆ«å®šä¹‰ <code>Val</code> å’Œ <code>Add</code> çš„èŠ‚ç‚¹ç±»å‹ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Val</span> e = <span class="hljs-type">Val</span> <span class="hljs-type">Int</span></span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">ValExpr</span> = <span class="hljs-type">Expr</span> <span class="hljs-type">Val</span></span>

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Add</span> e = <span class="hljs-type">Add</span> e e</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">AddExpr</span> = <span class="hljs-type">Expr</span> <span class="hljs-type">Add</span></span>
</code></pre>
<p>è¿™é‡Œçš„ <code>ValExpr</code> å°±æ˜¯åªæœ‰ <code>Val</code> èŠ‚ç‚¹çš„è¡¨è¾¾å¼ï¼ŒåŒç† <code>AddExpr</code> å°±æ˜¯åªæœ‰ <code>Add</code> èŠ‚ç‚¹çš„è¡¨è¾¾å¼ã€‚æŒ‰ç…§å‡½æ•°å¼çš„æ€æƒ³ï¼Œè¿˜éœ€è¦ä»€ä¹ˆä¸œè¥¿æ¥æŠŠå®ƒä»¬ç»„åˆèµ·æ¥æ‰èƒ½å½¢æˆå¤æ‚çš„è¡¨è¾¾å¼ã€‚</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> (<span class="hljs-title">f</span> :+: <span class="hljs-title">g</span>) e = <span class="hljs-type">Inl</span> (<span class="hljs-title">f</span> <span class="hljs-title">e</span>) | <span class="hljs-type">Inr</span> (<span class="hljs-title">g</span> <span class="hljs-title">e</span>)</span>
</code></pre>
<p>é‚£ä¹ˆ <code>Expr (f :+: g)</code> å°±å¯ä»¥è¡¨ç¤ºåŒ…å« <code>f</code> å’Œ <code>g</code> çš„è¡¨è¾¾å¼ã€‚é‚£ä¸ºä»€ä¹ˆæ˜¯ç±»ä¼¼äº <code>Either</code> çš„ç»“æ„å‘¢ï¼Ÿå› ä¸ºè¯¥ç±»å‹çš„å®ä¾‹è¡¨ç¤ºçš„ AST çš„æ ¹èŠ‚ç‚¹è¦ä¹ˆæ˜¯ <code>f</code> ç±»å‹çš„èŠ‚ç‚¹ï¼Œè¦ä¹ˆæ˜¯ <code>g</code> ç±»å‹çš„èŠ‚ç‚¹ã€‚ï¼ˆè€Œå­èŠ‚ç‚¹çš„ç±»å‹åˆæ¥è‡ª <code>e</code> ä¼ é€’çš„ä¸»è¡¨è¾¾å¼ç±»å‹ï¼‰ã€‚è¿™é‡Œå°±ä¸¾ä¸ªè¡¨ç¤º <code>119 + 1219</code> çš„ AST ä¾‹å­ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-title">addExample</span> :: <span class="hljs-type">Expr</span> (<span class="hljs-type">Val</span> :+: <span class="hljs-type">Add</span>)
<span class="hljs-title">addExample</span> = <span class="hljs-type">In</span> (<span class="hljs-type">Inr</span> (<span class="hljs-type">Add</span> (<span class="hljs-type">In</span> (<span class="hljs-type">Inl</span> (<span class="hljs-type">Val</span> <span class="hljs-number">119</span>)) (<span class="hljs-type">In</span> (<span class="hljs-type">Inl</span> (<span class="hljs-type">Val</span> <span class="hljs-number">1219</span>)))))
</code></pre>
<p>å¦‚æœæƒ³æ‰©å±•è¡¨è¾¾å¼ç±»å‹ï¼Œåªéœ€è¦å®šä¹‰ç±»å‹ç„¶åæŠŠå¤šä¸ªç±»å‹ç”¨ <code>:+:</code> ç»„åˆèµ·æ¥å°±å¯ä»¥äº†ã€‚æ¯”å¦‚å¦‚æœæƒ³å†åŠ ä¸ª <code>Sub</code> å°±å¯ä»¥ç”¨ <code>Expr (Val :+: Add :+: Sub)</code> è¡¨ç¤ºã€‚</p>
<h2 id="æ±‚å€¼">æ±‚å€¼</h2>
<p>å¾ˆæ˜¾ç„¶ï¼Œä¹‹å‰å®šä¹‰çš„å‡ ä¸ªè¡¨è¾¾å¼ç±»å‹åŒ…æ‹¬ <code>:+:</code> éƒ½æ˜¯ Functorï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">Val</span> <span class="hljs-keyword">where</span></span>
  fmap f (<span class="hljs-type">Val</span> x) = <span class="hljs-type">Val</span> x
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">Add</span> <span class="hljs-keyword">where</span></span>
  fmap f (<span class="hljs-type">Add</span> a b) = <span class="hljs-type">Add</span> (f a) (f b)
<span class="hljs-class">
<span class="hljs-keyword">instance</span> (<span class="hljs-type">Functor</span> <span class="hljs-title">f</span>, <span class="hljs-type">Functor</span> <span class="hljs-title">g</span>) =&gt; <span class="hljs-type">Functor</span> (<span class="hljs-title">f</span> :+: <span class="hljs-title">g</span>) <span class="hljs-keyword">where</span></span>
  fmap f (<span class="hljs-type">Inl</span> x) = <span class="hljs-type">Inl</span> (fmap f x)
  fmap f (<span class="hljs-type">Inr</span> x) = <span class="hljs-type">Inr</span> (fmap f x)
</code></pre>
<p>æ—¢ç„¶å®ƒä»¬æ˜¯ Functorï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨å®ƒä»¬ä¸Šé¢ foldï¼š</p>
<pre><code class="language-haskell"><span class="hljs-title">foldExpr</span> :: <span class="hljs-type">Functor</span> f =&gt; (f a -&gt; a) -&gt; <span class="hljs-type">Expr</span> f -&gt; a
<span class="hljs-title">foldExpr</span> f (<span class="hljs-type">In</span> x) = f (fmap (foldExpr f) x)
</code></pre>
<p>è€ƒè™‘å®šä¹‰ä¸€ä¸ª typeclass æ¥æè¿°å„è¡¨è¾¾å¼ç±»å‹çš„æ±‚å€¼æ–¹æ³•ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> f =&gt; <span class="hljs-type">Eval</span> f <span class="hljs-keyword">where</span></span>
  evalAlgebra :: f <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Eval</span> <span class="hljs-type">Val</span> <span class="hljs-keyword">where</span></span>
  evalAlgebra (<span class="hljs-type">Val</span> x) = x
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Eval</span> <span class="hljs-type">Add</span> <span class="hljs-keyword">where</span></span>
  evalAlgebra (<span class="hljs-type">Add</span> a b) = a + b
<span class="hljs-class">
<span class="hljs-keyword">instance</span> (<span class="hljs-type">Eval</span> <span class="hljs-title">f</span>, <span class="hljs-type">Eval</span> <span class="hljs-title">g</span>) =&gt; <span class="hljs-type">Eval</span> (<span class="hljs-title">f</span> :+: <span class="hljs-title">g</span>) <span class="hljs-keyword">where</span></span>
  evalAlgebra (<span class="hljs-type">Inl</span> x) = evalAlgebra x
  evalAlgebra (<span class="hljs-type">Inr</span> x) = evalAlgebra x
</code></pre>
<p>è€Œæ±‚å€¼è¿‡ç¨‹æœ¬è´¨ä¸Šå°±æ˜¯åœ¨ AST ä¸Šå¯¹ <code>evalAlgebra</code> çš„ foldï¼š</p>
<pre><code class="language-haskell"><span class="hljs-title">eval</span> :: <span class="hljs-type">Eval</span> f =&gt; <span class="hljs-type">Expr</span> f -&gt; <span class="hljs-type">Int</span>
<span class="hljs-title">eval</span> = foldExpr evalAlgebra
</code></pre>
<p>äºæ˜¯å°±å¯ä»¥ç”¨ <code>eval addExample</code> æ±‚å‡º <code>119 + 1219</code> ä¸º <code>1137</code>ã€‚è¿™æ—¶å€™è‹¥æ˜¯æƒ³åŠ å…¥ <code>Sub</code> åˆ™åªéœ€è¦ä¸ºå…¶å®ç° <code>Functor</code> å’Œ <code>Eval</code> typeclassã€‚</p>
<blockquote>
<p>Haskell ä¸­æœ‰ä¸ªå« Finally Tagless çš„åŠæ³•ä¹ŸåŒæ ·å¯ä»¥ç”¨æ¥è§£å†³ Expression problemï¼Œå®é™…ä¸Šå®ƒçš„æ€è·¯å’Œè¿™é‡Œçš„ <code>Eval</code> éå¸¸ç±»ä¼¼ï¼Œåªæ˜¯æ‰©å±•åŠŸèƒ½çš„æ€è·¯ä¸å¤ªä¸€æ ·ã€‚è¿™é‡Œæ¨è <a href="https://zhuanlan.zhihu.com/p/53810286">åƒé‡Œå†°å°å†™å¾—ç›¸å…³æ–‡ç« </a> é‡Œé¢åŒ…æ‹¬äº† Java ä¸­çš„ Visitor æ¨¡å¼å’Œ Haskell ä¸­çš„ Finally Tagless çš„ä»‹ç»ã€‚</p>
<p>å°±ä¸ªäººæ„Ÿè§‰ï¼ŒData type Ã  la carte å’Œ Finally Tagless æ€è·¯æŒºç›¸ä¼¼ï¼Œä½†æ˜¯ Data type Ã  la carte çš„ç»„åˆæ¨¡å¼æ›´åŠ è‡ªç”±ï¼Œè€Œ Finally Tagless æ—¢ä¸éœ€è¦ <code>:+:</code> å’Œè‡ªåŠ¨æ³¨å…¥ä¹‹ç±»çš„åŸºç¡€å·¥å…·æ”¯æŒä¹Ÿä¸éœ€è¦ OverlappingInstances è¿™æ ·çš„è¯­è¨€æ”¯æŒï¼Œç”¨èµ·æ¥æ›´è´´è¿‘åŸç”Ÿ Haskellã€‚</p>
</blockquote>
<h2 id="è‡ªåŠ¨æ³¨å…¥">è‡ªåŠ¨æ³¨å…¥</h2>
<p>ä»ä¸Šé¢çš„ä¾‹å­å¯ä»¥å‘ç° <code>addExample</code> çš„ä¾‹å­éå¸¸å¤æ‚ï¼Œè€Œä¸”å¦‚æœæŠŠç±»å‹ä¸­çš„ <code>Val</code> å’Œ <code>Add</code> æ¢ä¸ªé¡ºåºæˆ–åŠ å…¥ä¸€ä¸ª <code>Sub</code> å®ƒå°±ç›´æ¥ç‚¸äº†ï¼Œå¯ç§»æ¤æ€§å¾ˆå·®ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªèƒ½æŠŠå„èŠ‚ç‚¹è‡ªåŠ¨æ³¨å…¥åˆ°ç»„åˆç±»å‹ä¸­çš„æ™ºèƒ½æ„é€ å™¨æ¥è§£è€¦è¡¨è¾¾å¼å’Œå®ƒçš„ç±»å‹ã€‚è€ƒè™‘å½¢å¦‚ <code>a :+: b :+: c :+: ...</code> çš„ç»„åˆç±»å‹ <code>f</code> ï¼Œè‹¥è¿™ä¸ªåˆ—è¡¨ä¸­å­˜åœ¨ <code>Val</code> åˆ™æ™ºèƒ½æ„é€ å™¨ <code>val</code> å¯ä»¥è¢«æ³¨å…¥å…¶ä¸­ã€‚æˆ‘ä»¬å®šä¹‰ä¸€ä¸ª typeclass è¿ç®—ç¬¦ <code>:&lt;:</code> æ¥è¡¨ç¤ºå¯ä»¥æ³¨å…¥çš„å…³ç³»ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> (<span class="hljs-type">Functor</span> <span class="hljs-title">f</span>, <span class="hljs-type">Functor</span> <span class="hljs-title">g</span>) =&gt; f :&lt;: g <span class="hljs-keyword">where</span></span>
  inj :: f a -&gt; g a
</code></pre>
<p>è€Œè¿™ä¸ª <code>:+:</code> ä¸­çš„ <code>inj</code> åˆ™ç”¨äºç”ŸæˆèŠ‚ç‚¹ <code>f</code> åœ¨ç»„åˆç±»å‹ <code>g</code> ä¸­ç”± <code>Inl</code> å’Œ <code>Inr</code> ç»„æˆçš„æ„é€ è·¯å¾„ã€‚å°±æ¯”å¦‚åœ¨ <code>addExample</code> ä¸­ï¼Œå¯¹äº <code>Val :&lt;: (Val :+: Add :+: Sub)</code> åˆ™å¯ä»¥ç”Ÿæˆ <code>Inl</code>ï¼Œè€Œå¯¹äº <code>Add :&lt;: (Val :+: Add :+: Sub)</code> åˆ™å¯ä»¥ç”Ÿæˆ <code>Inr . Inl</code>ã€‚</p>
<p>è€Œå®ƒçš„å…·ä½“å®ç°å°±æ˜¯åœ¨è¿™åŸç†åŸºç¡€ä¸Šçš„å½’çº³ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> (<span class="hljs-type">Functor</span> <span class="hljs-title">f</span>) =&gt; f :&lt;: f <span class="hljs-keyword">where</span></span>
  inj = id
<span class="hljs-class">
<span class="hljs-keyword">instance</span> (<span class="hljs-type">Functor</span> <span class="hljs-title">f</span>, <span class="hljs-type">Functor</span> <span class="hljs-title">g</span>) =&gt; f :&lt;: (<span class="hljs-title">f</span> :+: <span class="hljs-title">g</span>) <span class="hljs-keyword">where</span></span>
  inj = <span class="hljs-type">Inl</span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> (<span class="hljs-type">Functor</span> <span class="hljs-title">f</span>, <span class="hljs-type">Functor</span> <span class="hljs-title">g</span>, <span class="hljs-type">Functor</span> <span class="hljs-title">h</span>, <span class="hljs-title">f</span> :&lt;: <span class="hljs-title">g</span>) =&gt; f :&lt;: (<span class="hljs-title">h</span> :+: <span class="hljs-title">g</span>) <span class="hljs-keyword">where</span></span>
  inj = <span class="hljs-type">Inr</span> . inj
</code></pre>
<p>æœ‰äº†æ„é€ è·¯å¾„å†å¥—ä¸Šä¸€ä¸ª <code>In</code>ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä¸º <code>Expr</code> æ„é€ å‡ºç‰¹åŒ–çš„è‡ªåŠ¨æ³¨å…¥å‡½æ•°å¹¶ä¸ºå„è¡¨è¾¾å¼èŠ‚ç‚¹ç±»å‹æ„é€ æ™ºèƒ½æ„é€ å™¨ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-title">inject</span> :: (f :&lt;: g) =&gt; g (<span class="hljs-type">Expr</span> f) -&gt; <span class="hljs-type">Expr</span> f
<span class="hljs-title">inject</span> = <span class="hljs-type">In</span> . inj

<span class="hljs-title">val</span> :: (<span class="hljs-type">Val</span> :&lt;: f) =&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Expr</span> f
<span class="hljs-title">val</span> x = inject (<span class="hljs-type">Val</span> x)

<span class="hljs-title">add</span> :: (<span class="hljs-type">Add</span> :&lt;: f) =&gt; <span class="hljs-type">Expr</span> f -&gt; <span class="hljs-type">Expr</span> f -&gt; <span class="hljs-type">Expr</span> f
<span class="hljs-title">add</span> x y = inject (<span class="hljs-type">Add</span> x y)
</code></pre>
<p>åˆ©ç”¨ typeclass çº¦æŸï¼Œè¿™é‡Œçš„ <code>val</code> å’Œ <code>add</code> å¯ä»¥è¢«æ³¨å…¥åˆ°ä»»æ„åŒ…å«å¯¹åº”ç±»å‹çš„ <code>f</code> ç»„åˆç±»å‹ä¸­ã€‚</p>
<p>è¿™æ ·å°±å¯ä»¥è½»æ¾æ„é€ å‡º AST äº†ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-title">injExample</span> :: <span class="hljs-type">Expr</span> (<span class="hljs-type">Val</span> :+: <span class="hljs-type">Add</span>)
<span class="hljs-title">injExample</span> = add (val <span class="hljs-number">30000</span>) (add (val <span class="hljs-number">1330</span>) (val <span class="hljs-number">7</span>))
</code></pre>
<p>ç”¨ <code>eval injExample</code> å°±å¯ä»¥å¾—åˆ° <code>31337</code>ï¼Œè€Œä¸”ä¸ç®¡æ€ä¹ˆä¿®æ”¹ <code>injExample</code> çš„ç±»å‹ï¼Œåªè¦åˆ—è¡¨é‡Œé¢åŒ…å« <code>Val</code> å’Œ <code>Add</code> éƒ½èƒ½è‡ªåŠ¨ç”Ÿæˆæ­£ç¡®çš„ ASTã€‚</p>
<h2 id="æ›´å¤šä¾‹å­">æ›´å¤šä¾‹å­</h2>
<p>åœ¨ä¸Šé¢ <code>Val :+: Add</code> çš„åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬å†å°è¯•åŠ å…¥ <code>Mul</code> èŠ‚ç‚¹ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Mul</span> e = <span class="hljs-type">Mul</span> e e</span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">Mul</span> <span class="hljs-keyword">where</span></span>
  fmap f (<span class="hljs-type">Mul</span> x y) = <span class="hljs-type">Mul</span> (f x) (f y)
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Eval</span> <span class="hljs-type">Mul</span> <span class="hljs-keyword">where</span></span>
  evalAlgebra (<span class="hljs-type">Mul</span> x y) = x * y

<span class="hljs-title">mul</span> :: (<span class="hljs-type">Mul</span> :&lt;: f) =&gt; <span class="hljs-type">Expr</span> f -&gt; <span class="hljs-type">Expr</span> f -&gt; <span class="hljs-type">Expr</span> f
<span class="hljs-title">mul</span> x y = inject (<span class="hljs-type">Mul</span> x y)
</code></pre>
<p>å°±åªéœ€è¦åŠ è¿™ä¹ˆå‡ è¡Œå°±å¯ä»¥åœ¨åŸæ¥çš„åŠŸèƒ½ä¸Šå¢åŠ  <code>Mul</code> èŠ‚ç‚¹äº†ï¼Œå®Œå…¨ä¸éœ€è¦ä¿®æ”¹åŸæœ¬çš„ä»£ç ã€‚ç„¶ååœ¨æ­¤åŸºç¡€ä¸Šæ‰©å±•æ‰“å°åŠŸèƒ½ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Render</span> f <span class="hljs-keyword">where</span></span>
  render :: (<span class="hljs-type">Render</span> g) =&gt; f (<span class="hljs-type">Expr</span> g) -&gt; <span class="hljs-type">String</span>

<span class="hljs-title">pretty</span> :: (<span class="hljs-type">Render</span> f) =&gt; <span class="hljs-type">Expr</span> f -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">pretty</span> (<span class="hljs-type">In</span> x) = render x
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Render</span> <span class="hljs-type">Val</span> <span class="hljs-keyword">where</span></span>
  render (<span class="hljs-type">Val</span> x) = show x
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Render</span> <span class="hljs-type">Add</span> <span class="hljs-keyword">where</span></span>
  render (<span class="hljs-type">Add</span> x y) = <span class="hljs-string">&quot;(&quot;</span> ++ pretty x ++ <span class="hljs-string">&quot; + &quot;</span> ++ pretty y ++ <span class="hljs-string">&quot;)&quot;</span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Render</span> <span class="hljs-type">Mul</span> <span class="hljs-keyword">where</span></span>
  render (<span class="hljs-type">Mul</span> x y) = <span class="hljs-string">&quot;(&quot;</span> ++ pretty x ++ <span class="hljs-string">&quot; * &quot;</span> ++ pretty y ++ <span class="hljs-string">&quot;)&quot;</span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Render</span> f =&gt; <span class="hljs-type">Render</span> (<span class="hljs-title">f</span> :+: <span class="hljs-title">g</span>) <span class="hljs-keyword">where</span></span>
  render (<span class="hljs-type">Inl</span> x) = render x
  render (<span class="hljs-type">Inr</span> x) = render x
</code></pre>
<p>åŒæ ·åªéœ€è¦æ·»åŠ æ–°ä»£ç è€Œä¸éœ€è¦æ”¹åŠ¨åŸä»£ç ã€‚ç”¨ <code>pretty injExample</code> å°±å¯ä»¥å¾—åˆ° <code>&quot;(30000 + (1330 + 7))&quot;</code>ã€‚</p>
<blockquote>
<p>è¿™ä¸ª <code>Render</code> çš„ä¾‹å­åœ¨åŸè®ºæ–‡ä¸­å¹¶æ²¡æœ‰åƒä¹‹å‰çš„ <code>Eval</code> ä½¿ç”¨ fold æ¥å®šä¹‰è€Œæ˜¯ç›´æ¥é€’å½’ï¼Œè¯´å®è¯æˆ‘è¿˜æŒºå›°æƒ‘çš„ï¼Œå¼ºè¿«ç—‡è¡¨ç¤ºçœ‹ç€å¾ˆä¸èˆ’æœã€‚å¦‚æœè¯´æƒ³åƒä¹‹å‰é‚£æ ·ç”¨ fold å®šä¹‰åº”è¯¥æ˜¯è¿™æ ·çš„ï¼ˆå¹¶æ²¡æœ‰ç¼–è¯‘è¿è¡ŒéªŒè¯è¿‡ï¼‰ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Render</span> f <span class="hljs-keyword">where</span></span>
    render :: f <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Render</span> <span class="hljs-type">Val</span> <span class="hljs-keyword">where</span></span>
    render (<span class="hljs-type">Val</span> x) = show x
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Render</span> <span class="hljs-type">Add</span> <span class="hljs-keyword">where</span></span>
    render (<span class="hljs-type">Add</span> x y) = <span class="hljs-string">&quot;(&quot;</span> ++ x ++ <span class="hljs-string">&quot; + &quot;</span> ++ y ++ <span class="hljs-string">&quot;)&quot;</span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Render</span> <span class="hljs-type">Mul</span> <span class="hljs-keyword">where</span></span>
    render (<span class="hljs-type">Mul</span> x y) = <span class="hljs-string">&quot;(&quot;</span> ++ x ++ <span class="hljs-string">&quot; * &quot;</span> ++ y ++ <span class="hljs-string">&quot;)&quot;</span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> (<span class="hljs-type">Render</span> <span class="hljs-title">f</span>, <span class="hljs-type">Render</span> <span class="hljs-title">g</span>) =&gt; <span class="hljs-type">Render</span> (<span class="hljs-title">f</span> :+: <span class="hljs-title">g</span>) <span class="hljs-keyword">where</span></span>
    render (<span class="hljs-type">Inl</span> x) = render x
    render (<span class="hljs-type">Inr</span> x) = render x

<span class="hljs-title">pretty</span> :: (<span class="hljs-type">Render</span> f) =&gt; <span class="hljs-type">Expr</span> f -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">pretty</span> = foldExpr render
</code></pre>
</blockquote>
<p>å¦å¤–ï¼Œ<code>f :&lt;: g</code> æ—¢ç„¶èƒ½æŠŠç±»å‹ <code>f</code> çš„å®ä¾‹æ³¨å…¥æˆç»„åˆç±»å‹ <code>g</code>ï¼Œé‚£ä¹Ÿåº”è¯¥å­˜åœ¨ä¸€ä¸ªåå‡½æ•°æŠŠ <code>g</code> çš„å®ä¾‹æŠ•å°„åˆ° <code>f</code> ä¸Šï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> (<span class="hljs-type">Functor</span> <span class="hljs-title">f</span>, <span class="hljs-type">Functor</span> <span class="hljs-title">g</span>) =&gt; f :&lt;: g <span class="hljs-keyword">where</span></span>
  inj :: f a -&gt; g a
  prj :: g a -&gt; <span class="hljs-type">Maybe</span> (f a)
<span class="hljs-class">
<span class="hljs-keyword">instance</span> (<span class="hljs-type">Functor</span> <span class="hljs-title">f</span>) =&gt; f :&lt;: f <span class="hljs-keyword">where</span></span>
  inj = id
  prj = <span class="hljs-type">Just</span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> (<span class="hljs-type">Functor</span> <span class="hljs-title">f</span>, <span class="hljs-type">Functor</span> <span class="hljs-title">g</span>) =&gt; f :&lt;: (<span class="hljs-title">f</span> :+: <span class="hljs-title">g</span>) <span class="hljs-keyword">where</span></span>
  inj = <span class="hljs-type">Inl</span>
  prj (<span class="hljs-type">Inl</span> x) = <span class="hljs-type">Just</span> x
  prj _ = <span class="hljs-type">Nothing</span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> (<span class="hljs-type">Functor</span> <span class="hljs-title">f</span>, <span class="hljs-type">Functor</span> <span class="hljs-title">g</span>, <span class="hljs-type">Functor</span> <span class="hljs-title">h</span>, <span class="hljs-title">f</span> :&lt;: <span class="hljs-title">g</span>) =&gt; f :&lt;: (<span class="hljs-title">h</span> :+: <span class="hljs-title">g</span>) <span class="hljs-keyword">where</span></span>
  inj = <span class="hljs-type">Inr</span> . inj
  prj (<span class="hljs-type">Inr</span> x) = <span class="hljs-type">Just</span> x
  prj _ = <span class="hljs-type">Nothing</span>
</code></pre>
<p>è¿™ä¸ªæŠ•å°„åœ¨æœ‰äº›æ—¶å€™è¿˜æŒºæœ‰ç”¨ï¼Œæ¯”å¦‚å˜æ¢ AST çš„æ—¶å€™æœ‰å¯èƒ½éœ€è¦è§£æ„å®ä¾‹ã€‚è¿™é‡Œæœ‰ä¸ªä¹˜æ³•åˆ†é…å¾‹çš„ä¾‹å­ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-title">match</span> :: (f :&lt;: g) =&gt; <span class="hljs-type">Expr</span> f -&gt; <span class="hljs-type">Maybe</span> (g (<span class="hljs-type">Expr</span> f))
<span class="hljs-title">match</span> (<span class="hljs-type">In</span> x) = prj x

<span class="hljs-title">distr</span> :: (<span class="hljs-type">Add</span> :&lt;: f, <span class="hljs-type">Mul</span> :&lt;: f) =&gt; <span class="hljs-type">Expr</span> f -&gt; <span class="hljs-type">Maybe</span> (<span class="hljs-type">Expr</span> f)
<span class="hljs-title">distr</span> t = <span class="hljs-keyword">do</span>
  <span class="hljs-type">Mul</span> a b &lt;- match t
  <span class="hljs-type">Add</span> c d &lt;- match b
  pure (add (mul a c) (mul a d))
</code></pre>
<p>åœ¨çŸ¥é“åŸè¡¨è¾¾å¼ <code>t</code> çš„ç»“æ„ä¸º <code>mul a (add c d)</code> çš„æƒ…å†µä¸‹åˆ©ç”¨æŠ•å°„åŒ¹é…å¾—åˆ° <code>a</code> <code>b</code> <code>c</code> ç„¶åå†é‡æ–°ç»„åˆã€‚</p>
<h2 id="monads-for-free">Monads for free</h2>
<p>è€ƒè™‘å¯¹ <code>Expr</code> åšå‡ºå¦‚ä¸‹ä¿®æ”¹ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Term</span> f a = <span class="hljs-type">Pure</span> a | <span class="hljs-type">Impure</span> (<span class="hljs-title">f</span> (<span class="hljs-type">Term</span> <span class="hljs-title">f</span> <span class="hljs-title">a</span>))</span>
</code></pre>
<p>å®ƒåŒ…å«äº†æ— å‰¯ä½œç”¨çš„å€¼å’Œå¸¦å‰¯ä½œç”¨çš„æ“ä½œã€‚</p>
<p>å¯ä»¥è¯æ˜å¦‚æœå‚æ•° <code>f</code> æ˜¯ä¸€ä¸ª Functor é‚£ä¹ˆå®ƒæ˜¯ä¸€ä¸ª Monadï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> f =&gt; <span class="hljs-type">Functor</span> (<span class="hljs-type">Term</span> <span class="hljs-title">f</span>) <span class="hljs-keyword">where</span></span>
  fmap f (<span class="hljs-type">Pure</span> x) = <span class="hljs-type">Pure</span> (f x)
  fmap f (<span class="hljs-type">Impure</span> x) = <span class="hljs-type">Impure</span> (fmap (fmap f) x)
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> f =&gt; <span class="hljs-type">Applicative</span> (<span class="hljs-type">Term</span> <span class="hljs-title">f</span>) <span class="hljs-keyword">where</span></span>
  pure = <span class="hljs-type">Pure</span>
  <span class="hljs-type">Pure</span> f &lt;*&gt; x = fmap f x
  <span class="hljs-type">Impure</span> f &lt;*&gt; x = <span class="hljs-type">Impure</span> (fmap (&lt;*&gt; x) f)
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> f =&gt; <span class="hljs-type">Monad</span> (<span class="hljs-type">Term</span> <span class="hljs-title">f</span>) <span class="hljs-keyword">where</span></span>
  <span class="hljs-type">Pure</span> x &gt;&gt;= f = f x
  <span class="hljs-type">Impure</span> x &gt;&gt;= f = <span class="hljs-type">Impure</span> (fmap (&gt;&gt;= f) x)
</code></pre>
<p>è¿™å°±æ˜¯è‘—åçš„ Free Monadï¼Œå®ƒèƒ½æŠŠä»»æ„ Functor å˜æˆ Monadã€‚</p>
<blockquote>
<p>åŸè®ºæ–‡å¹¶æ²¡æœ‰å®ç° Applicativeï¼Œæ®è¯´æ˜¯å› ä¸ºæ›¾ç» Monad å¹¶ä¸ä¾èµ–äº Applicativeï¼Œè¿™ä¹Ÿæ˜¯æ›¾ç» Monad å…·æœ‰ <code>return</code> è¿™æ ·ä¸€ä¸ªå’Œ <code>pure</code> åŠŸèƒ½é‡å¤çš„å‡½æ•°çš„åŸå› ã€‚</p>
<p>æœ‰äº›äººè§‰å¾—è¿™é‡Œçš„ Free ç¿»è¯‘ä¸ºã€Œå…è´¹ã€å› ä¸ºå®ƒå¯ä»¥ä¸éœ€è¦é¢å¤–ä»£ç å°±èƒ½æŠŠä¸€ä¸ª Functor å˜æˆ Monadï¼Œä¸è¿‡å¦ä¸€äº›äººè§‰å¾—åº”è¯¥ç¿»è¯‘æˆã€Œè‡ªç”±ã€å› ä¸ºåœ¨æ€§è´¨ä¸Šæ˜¯å’Œ Forgetful ç›¸åçš„ï¼Œå®ƒå¯ä»¥è‡ªç”±æ‰©å±•è€Œä¸éœ€è¦ä¿®æ”¹åŸä»£ç ã€‚</p>
</blockquote>
<p>å¾ˆå¤šä½ ç†Ÿæ‚‰çš„ Monad éƒ½å¯ä»¥ç”± Free Monad æ„é€ ï¼Œè€ƒè™‘ä»¥ä¸‹ç±»å‹ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Zero</span> a</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">One</span> a = <span class="hljs-type">One</span></span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Const</span> e a = <span class="hljs-type">Const</span> e</span>
</code></pre>
<p>äºæ˜¯ <code>Term Zero</code> å®é™…ä¸Šå°±æ˜¯åªä¿å­˜ä¸€ä¸ªå€¼çš„å•ä½ Monadï¼Œ<code>Term One</code> æ˜¯ <code>Maybe</code>ï¼Œ <code>Term (Const e)</code> åˆ™æ˜¯ <code>Either e</code>ã€‚ä¸è¿‡åŒæ ·ä¹Ÿæœ‰å¾ˆå¤š Monad å¹¶ä¸æ˜¯ Free çš„ï¼Œæ¯”å¦‚ <code>List</code> å’Œ <code>State</code>ã€‚</p>
<p>å°½ç®¡ <code>State</code> ä¸æ˜¯ Free Monad ä½†åˆ©ç”¨ <code>Term</code> å¯ä»¥ç”¨æ¥è¡¨ç¤ºå…·æœ‰çŠ¶æ€çš„è®¡ç®—è¯­è¨€ã€‚è¿™é‡Œä¸¾ä¸ªèƒ½è·å–å€¼ (Recall)ã€å¢åŠ å€¼ (Incr) å’Œæ¸…ç©ºå€¼ (Clear) çš„ä¾‹å­ï¼š</p>
<blockquote>
<p>Clear åŠŸèƒ½åœ¨åŸè®ºæ–‡ä¸­æ˜¯ä¸ªç»ƒä¹ ï¼Œè¿™é‡Œé¡ºæ‰‹å†™äº†ã€‚</p>
</blockquote>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Recall</span> t = <span class="hljs-type">Recall</span> (<span class="hljs-type">Int</span> -&gt; <span class="hljs-title">t</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Incr</span> t = <span class="hljs-type">Incr</span> <span class="hljs-type">Int</span> t</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Clear</span> t = <span class="hljs-type">Clear</span> t</span>

<span class="hljs-title">inject</span> :: (f :&lt;: g) =&gt; f (<span class="hljs-type">Term</span> g a) -&gt; <span class="hljs-type">Term</span> g a
<span class="hljs-title">inject</span> = <span class="hljs-type">Impure</span> . inj

<span class="hljs-title">recall</span> :: (<span class="hljs-type">Recall</span> :&lt;: f) =&gt; <span class="hljs-type">Term</span> f <span class="hljs-type">Int</span>
<span class="hljs-title">recall</span> = inject (<span class="hljs-type">Recall</span> pure)

<span class="hljs-title">incr</span> :: (<span class="hljs-type">Incr</span> :&lt;: f) =&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Term</span> f ()
<span class="hljs-title">incr</span> n = inject (<span class="hljs-type">Incr</span> n (pure ()))

<span class="hljs-title">clear</span> :: (<span class="hljs-type">Clear</span> :&lt;: f) =&gt; <span class="hljs-type">Term</span> f ()
<span class="hljs-title">clear</span> = inject (<span class="hljs-type">Clear</span> (pure ()))
</code></pre>
<p>åˆ©ç”¨ Haskell çš„ do è¯­æ³•ç³–å¯ä»¥è½»æ¾æ„é€ å‡ºå¤æ‚çš„è¯­å¥ï¼Œè¿™é‡Œä¸¾ä¸ªç»™çŠ¶æ€å€¼å¢åŠ  1 ç„¶åè¿”å›åŸå§‹å€¼çš„ä¾‹å­ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-title">tick</span> :: <span class="hljs-type">Term</span> (<span class="hljs-type">Recall</span> :+: <span class="hljs-type">Incr</span>) <span class="hljs-type">Int</span>
<span class="hljs-title">tick</span> = <span class="hljs-keyword">do</span>
  x &lt;- recall
  incr <span class="hljs-number">1</span>
  pure x
</code></pre>
<p>è¿™é‡Œçš„ <code>tick</code> ä¹Ÿå¯é‡‡ç”¨æ›´æ³›åŒ–çš„ç±»å‹ <code>(Recall :&lt;: f, Incr :&lt;: f) =&gt; Term f Int</code>ï¼Œè¿™æ ·å°±èƒ½åœ¨ä»»ä½•åŒ…å« <code>Recall</code> å’Œ <code>Incr</code> çš„ <code>Term</code> ä¸­è°ƒç”¨äº†ã€‚</p>
<p>æ¥ä¸‹æ¥å°±æŒ‰ç…§ä¹‹å‰ <code>Expr</code> çš„ç»éªŒæ¥å†™å‡º <code>Term</code> çš„è§£é‡Šå™¨ï¼Œåªä¸è¿‡è¿™é‡Œä¸ºäº†ä¼ é€’çŠ¶æ€éœ€è¦ fold å‡ºä¸€ä¸ªç­¾åä¸º <code>... =&gt; Term f a -&gt; Int -&gt; (a, Int)</code> å‡½æ•°ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- ç¬¬ä¸€ä¸ªå‚æ•°ç”¨æ¥æŠ˜å  Pureï¼Œç¬¬äºŒä¸ªå‚æ•°ç”¨æ¥æŠ˜å  Impure</span>
<span class="hljs-title">foldTerm</span> :: <span class="hljs-type">Functor</span> f =&gt; (a -&gt; b) -&gt; (f b -&gt; b) -&gt; <span class="hljs-type">Term</span> f a -&gt; b
<span class="hljs-title">foldTerm</span> pure impure (<span class="hljs-type">Pure</span> x) = pure x
<span class="hljs-title">foldTerm</span> pure impure (<span class="hljs-type">Impure</span> x) = impure (fmap (foldTerm pure impure) x)
<span class="hljs-class">
<span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> f =&gt; <span class="hljs-type">Run</span> f <span class="hljs-keyword">where</span></span>
  runAlgebra :: f (<span class="hljs-type">Int</span> -&gt; (a, <span class="hljs-type">Int</span>)) -&gt; (<span class="hljs-type">Int</span> -&gt; (a, <span class="hljs-type">Int</span>))
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Run</span> <span class="hljs-type">Recall</span> <span class="hljs-keyword">where</span></span>
  runAlgebra (<span class="hljs-type">Recall</span> f) i = f i i
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Run</span> <span class="hljs-type">Incr</span> <span class="hljs-keyword">where</span></span>
  runAlgebra (<span class="hljs-type">Incr</span> n f) i = f (i + n)
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Run</span> <span class="hljs-type">Clear</span> <span class="hljs-keyword">where</span></span>
  runAlgebra (<span class="hljs-type">Clear</span> f) _ = f <span class="hljs-number">0</span>

<span class="hljs-title">run</span> :: (<span class="hljs-type">Run</span> f) =&gt; <span class="hljs-type">Term</span> f a -&gt; (<span class="hljs-type">Int</span> -&gt; (a, <span class="hljs-type">Int</span>))
<span class="hljs-title">run</span> = foldTerm (\a x -&gt; (a, x)) runAlgebra
<span class="hljs-comment">--    foldTerm (,) runAlgebra</span>
</code></pre>
<p>è¿™é‡Œ <code>run</code> çš„æ•ˆæœå°±å¾ˆç±»ä¼¼ <code>runState</code> äº†ã€‚äºæ˜¯ <code>run tick 4</code> å°±å¯ä»¥å¾—åˆ° <code>(4, 5)</code>ã€‚</p>
<h2 id="åº”ç”¨">åº”ç”¨</h2>
<p>ç±»ä¼¼äºä¹‹å‰çš„ <code>Expr</code> å¯ä»¥ç»„åˆä¸åŒçš„è¡¨è¾¾å¼èŠ‚ç‚¹ï¼Œ<code>Term</code> ä¹Ÿå¯ä»¥ç»„åˆä¸åŒçš„ Free Monad åˆ°ä¸€èµ·ä½¿ç”¨ã€‚è¿™é‡Œä¸¾ä¸ªç»ˆç«¯å’Œæ–‡ä»¶ç³»ç»Ÿæ··åˆè¾“å…¥è¾“å‡ºçš„ä¾‹å­ï¼š</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Teletype</span> a = </span>
    <span class="hljs-type">PutChar</span> <span class="hljs-type">Char</span> a 
  | <span class="hljs-type">GetChar</span> (<span class="hljs-type">Char</span> -&gt; a)
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">FileSystem</span> a = </span>
    <span class="hljs-type">WriteFile</span> <span class="hljs-type">FilePath</span> <span class="hljs-type">String</span> a 
  | <span class="hljs-type">ReadFile</span> <span class="hljs-type">FilePath</span> (<span class="hljs-type">String</span> -&gt; a)

<span class="hljs-comment">-- çœç•¥äº† Functor å®ç°</span>
<span class="hljs-class">
<span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> f =&gt; <span class="hljs-type">Exec</span> f <span class="hljs-keyword">where</span></span>
  execAlgebra :: f (<span class="hljs-type">IO</span> a) -&gt; <span class="hljs-type">IO</span> a
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Exec</span> <span class="hljs-type">Teletype</span> <span class="hljs-keyword">where</span></span>
  execAlgebra (<span class="hljs-type">PutChar</span> c x) = <span class="hljs-type">Prelude</span>.putChar c &gt;&gt; x
  execAlgebra (<span class="hljs-type">GetChar</span> f) = <span class="hljs-type">Prelude</span>.getChar &gt;&gt;= f
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Exec</span> <span class="hljs-type">FileSystem</span> <span class="hljs-keyword">where</span></span>
  execAlgebra (<span class="hljs-type">WriteFile</span> fp s x) = <span class="hljs-type">Prelude</span>.writeFile fp s &gt;&gt; x
  execAlgebra (<span class="hljs-type">ReadFile</span> fp f) = <span class="hljs-type">Prelude</span>.readFile fp &gt;&gt;= f

<span class="hljs-comment">-- çœç•¥äº†æ™ºèƒ½æ„é€ å™¨çš„å®ç°</span>

<span class="hljs-title">exec</span> :: (<span class="hljs-type">Exec</span> f) =&gt; <span class="hljs-type">Term</span> f a -&gt; <span class="hljs-type">IO</span> a
<span class="hljs-title">exec</span> = foldTerm pure execAlgebra

<span class="hljs-title">cat</span> :: (<span class="hljs-type">Teletype</span> :&lt;: f, <span class="hljs-type">FileSystem</span> :&lt;: f) =&gt; <span class="hljs-type">FilePath</span> -&gt; <span class="hljs-type">Term</span> f ()
<span class="hljs-title">cat</span> fp = <span class="hljs-keyword">do</span>
  contents &lt;- readFile fp
  mapM putChar contents
  pure ()
</code></pre>
<h2 id="ç©ç«çš„åè®°">ç©ç«çš„åè®°</h2>
<p>è®°å½•ä¸€äº›è¯»å®ŒåŸè®ºæ–‡åçš„æƒ³æ³•ï¼Œç®—æ˜¯ä¸€äº›åŸæ–‡æ²¡æ˜è¯´çš„ä¸ªäººç†è§£ã€‚</p>
<h3 id="å…³äºå‘½å">å…³äºå‘½å</h3>
<p>æ‰€è°“ç‚¹èœ (Ã  la carte) å°±æ˜¯æŒ‡åˆ†å¼€ç‚¹çš„èœï¼Œè¿™æ ·ç¼–ç¨‹å°±å¥½åƒåœ¨ä¸€å®¶é¤å…ç‚¹èœï¼Œé¤å…é¢„å…ˆå‡†å¤‡äº†å¯ä»¥ç”¨æ¥ã€Œç‚’ã€çš„å‡ ä¸ªèœï¼Œå¯ä»¥ç”¨æ¥ã€Œç‚–ã€çš„å‡ ä¸ªèœï¼ˆåº“ä¸­å®ç°äº†æ±‚å€¼çš„å‡ ä¸ªèŠ‚ç‚¹ç±»å‹ï¼Œå®ç°äº†æ‰“å°çš„å‡ ä¸ªèŠ‚ç‚¹ç±»å‹ï¼‰ï¼Œè€Œæˆ‘å°±å¯ä»¥æŒ‰ç…§æˆ‘çš„éœ€æ±‚æŠŠè¥¿çº¢æŸ¿å’Œé¸¡è›‹ç»„åˆèµ·æ¥ï¼ˆæŠŠ <code>Teletype</code> å’Œ <code>FileSystem</code> çš„èŠ‚ç‚¹ç»„åˆæˆ <code>cat</code> è¿™æ ·çš„ ASTï¼‰ï¼Œç„¶åè¦æ±‚å¨å¸ˆæŠŠå®ƒä»¬ç‚’æˆä¸€ç›˜èœï¼ˆé€šè¿‡ <code>exec cat</code> ç”Ÿæˆå¯æ‰§è¡Œä»£ç ï¼‰ã€‚</p>
<p>æ‰€ä»¥æˆ‘æ„Ÿè§‰è¿™ä¸ªå‘½åå°±éå¸¸æœ‰çµæ€§ã€‚</p>
<h3 id="å…³äº-effect">å…³äº Effect</h3>
<p>ä¸ªäººæ„Ÿè§‰è¿™ç©æ„ç‰¹åˆ«é€‚åˆæ‹¿æ¥æ Effect Systemï¼Œæ–‡æœ«çš„ <code>cat</code> ä¾‹å­å°±å¾ˆèƒ½è¯´æ˜å®ƒçš„æ½œåŠ›ã€‚å¯¹äºå¤šç§ Monad æ··ç”¨çš„æƒ…å†µï¼Œç›®å‰ Haskell çš„ä¸»æµæ–¹æ¡ˆï¼ˆæ ‡å‡†åº“æ–¹æ¡ˆï¼‰æ˜¯ Monad Transformerï¼Œä½†æ˜¯è¿™ç©æ„ä¸€æ–¹é¢ç»„åˆå¤šäº† lift èµ·æ¥éå¸¸éº»çƒ¦ï¼Œå¦ä¸€æ–¹é¢ä½¿ç”¨çš„æ—¶å€™æå…¶ä¾èµ– Monad çš„ç»„åˆé¡ºåºï¼Œéå¸¸ä¸çµæ´»ï¼Œå¯ä»¥è¯´æ˜¯æ¯”è¾ƒéš¾ç”¨çš„æ–¹æ¡ˆã€‚è€Œç‚¹èœæ•°æ®ç±»å‹åªéœ€è¦æŒ‡æ˜ç”¨äº†å“ªäº› Effect å°±èƒ½è‡ªåŠ¨å¤„ç†å¤æ‚ç»„åˆå’Œæ‰©å±•é—®é¢˜ï¼Œè€Œä¸”å®ƒèƒ½åœ¨å®ç° <code>Exec</code> æ—¶è°ƒç”¨ <code>lift</code> ä»è€Œå®Œç¾å¯¹æ¥ Monad Transformer åŸæœ‰çš„å‡½æ•°å®ç°ã€‚</p>
<p>å”¯ä¸€æƒ³åæ§½çš„æ˜¯æ³›åŒ–çš„ç±»å‹ä¾èµ–åˆ—è¡¨åœ¨æ— è¯­æ³•ç³–çš„æƒ…å†µä¸‹å†™å‡ºæ¥çœŸæ˜¯å·¨é•¿ï¼Œè€Œä¸”æ²¡åŠæ³•ç”¨å…¨å±€å˜é‡è¡¨è¾¾ä»è€Œç®€åŒ–ä¾èµ–é•¿åº¦ã€‚å¦‚æœç¼–è¯‘å™¨å†æ¥ä¸ªè‡ªåŠ¨æ¨å¯¼ä¾èµ–åˆ—è¡¨çš„åŠŸèƒ½é‚£å°†æ˜¯ç»æ€ï¼Œå¯æƒœæš‚æ—¶åŠ ä¸å¾—ã€‚</p>
<h3 id="å…³äº-free-monad">å…³äº Free Monad</h3>
<p>ç”±äº <code>Impure</code> çš„é€’å½’æ€§è´¨ï¼Œåªè¦ç»™å‡ºåˆé€‚çš„ <code>f</code>ï¼Œå®é™…ä¸Šå®ƒèƒ½æ„é€ å‡ºä»»æ„å½¢çŠ¶çš„ç»“æ„ï¼Œä½†æ˜¯ä¸ºäº†ä¿è¯ Monad æ€§è´¨è€Œå­˜åœ¨çš„ <code>Pure</code> ä½¿ Free Monad ä¸èƒ½å’Œä¸€äº› Monad å®Œç¾åŒ¹é…ï¼Œæ¯”å¦‚æ–‡ä¸­æåˆ°çš„ <code>data [a] = Nil | a : [a]</code> å°±ä¸å­˜åœ¨å’Œ <code>Pure a</code> ç±»ä¼¼çš„æ„é€ å™¨ã€‚ä¸è¿‡ç”±äºå®Œå¤‡çš„ <code>Impure</code> çš„å­˜åœ¨ï¼Œæ‰€æœ‰ ADT éƒ½èƒ½åµŒå…¥åˆ° Free Monad å½“ä¸­ã€‚æ‰€ä»¥å°½ç®¡ä¸æ˜¯æ‰€æœ‰çš„ Monad éƒ½æ˜¯ Free Monadï¼Œä½† Free Monad æ€»èƒ½å®ç°å®ƒä»¬çš„å®é™…åŠŸèƒ½ã€‚è¿™äº‹å°±æœ‰ç‚¹ç±»ä¼¼äºç»å…¸é€»è¾‘èƒ½åµŒå…¥åˆ°ç›´è§‰ä¸»ä¹‰é€»è¾‘ï¼Œå°±æˆ‘ä¸ªäººè§‰å¾—ç›´æ¥æ‹¿æ›´ã€Œå¤§ã€çš„ç³»ç»Ÿç”¨ä¹Ÿæ²¡å•¥é—®é¢˜ã€‚</p>
<h3 id="åœ¨å…¶ä»–è¯­è¨€ä¸­çš„è¿ç”¨">åœ¨å…¶ä»–è¯­è¨€ä¸­çš„è¿ç”¨</h3>
<p>æˆ‘å†™ä¹‹å‰åœ¨ç½‘ä¸Šæœäº†æœçœ‹çœ‹æœ‰æ²¡æœ‰åˆ«çš„äººå†™è¿‡ç¿»è¯‘ï¼Œç»“æœå‘ç°äº†ä¸€ä¸ª <a href="https://github.com/jcouyang/alacarte/wiki/%E8%AF%BB%E6%88%91">å¥‡å¦™çš„ä»“åº“</a> ï¼Œä½œè€…æŠŠç‚¹èœæ•°æ®ç±»å‹æ¬åˆ° JavaScript é‡Œé¢äº†ï¼Œè¿˜ä¸ºå®ƒå®ç°äº†ä¸€ä¸ªè¿è¡Œæ—¶çš„æ³¨å…¥æ£€æŸ¥ã€‚æ„Ÿè§‰éå¸¸ç¦»è°±ã€‚ä¸è¿‡ç”±äº Overlapping Instances çš„å­˜åœ¨ï¼Œç›®æµ‹ä¸»æµè¯­è¨€é‡Œä¹Ÿå°± C++ èƒ½åŸç”Ÿåœ¨ç¼–è¯‘æœŸåšåˆ°æ³¨å…¥æ£€æŸ¥ã€‚</p>
</body>
</html>
